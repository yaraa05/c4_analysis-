1. What is the purpose of the next() function, and how does it contribute to the compilation process?The next() function reads the source code one character at a time and turns it into "tokens" (like keywords, operators, or variables). These tokens help the compiler understand the code. Without it, the compiler wouldn't know what the code actually means.2. How does C4 handle symbol resolution (e.g., variables, functions)?C4 uses a symbol table to keep track of variables and functions. When the compiler sees a name (like a variable or function), it checks the symbol table to see if it's already been defined and finds out what type it is and where it’s stored.3. What are the limitations of C4 as a compiler? What features of C does it not support?C4 is simple and doesn't support all features of C. For example, it doesn't handle complex things like structs, floating-point numbers, or advanced file operations. It also doesn't optimize code as well as other compilers, and its error handling is basic.4. How does C4 achieve self-hosting (i.e., compiling itself)? What are the implications of this design?C4 can compile its own source code (self-hosting). It does this by first compiling a simple version of itself, then using that to compile the rest of the code. The benefit is that C4 is easy to understand and modify, but the downside is that it’s not as powerful or fast as bigger compilers.