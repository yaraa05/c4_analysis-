// c4.c - C in four functions

// char, int, and pointer types
// if, while, return, and expression statements
// just enough features to allow self-compilation and a bit more

// Written by Robert Swierczek

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>
#include <fcntl.h>
//#define int long long  // Redefine 'int' as a long long (64-bit) integer type throughout the compiler.


// Global pointers for source code and data management
// 'p' points to the current position in the source code buffer.
// 'lp' marks the beginning of the current line (useful for debugging).

char *p, *lp, // current position in source code
     *data;   // data/bss pointer

int *e, *le,  // current position in emitted code, 'e' points to the current position and 'le' is used for debugging.
    *id,      // currently parsed identifier
    *sym,     // symbol table implemented as an array of integers (simple list of identifiers), where each identifier occupies a fixed number of slots.
    tk,       // current token
    ival,     // current token value
    ty,       // current expression type
    loc,      // local variable offset
    line,     // current line number
    src,      // print source and assembly flag
    debug;    // print executed instructions

// tokens and classes (operators last and in precedence order)
// Token types, keywords, and operators are defined as enumerated constants.
// They serve as the vocabulary for the lexical analyzer.

enum {
  Num = 128, Fun, Sys, Glo, Loc, Id, //tokens
  Char, Else, Enum, If, Int, Return, Sizeof, While, //keywords
  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak //operators and punctuation
};

// This enum lists the opcodes for the virtual machine.
// Each opcode represents a simple instruction generated by the compiler.
//correspond to basic operations like loading addresses, jumping, calling subroutines, and arithmetic operations.
enum { LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,
       OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,
       OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT }; 

// types
enum { CHAR, INT, PTR };

// identifier offsets (since we can't create an ident struct)
//Every identifier is represented by an array of integers holding its token type, hash value, name pointer, class, type, value, and backup fields for when local variables are overwritten.
enum { Tk, Hash, Name, Class, Type, Val, HClass, HType, HVal, Idsz };



// The 'next()' function is the lexical analyzer. It reads the source code from pointer 'p' and converts it into tokens (stored in 'tk').
// It also handles line breaks, identifiers, numbers, strings, comments, and operators.
void next()
{
  char *pp; // Temporary pointer used for scanning identifiers and strings
  // Main loop: continue reading characters until a valid token is produced (or end-of-file)
  while (tk = *p) { // Assign current character from source to 'tk'; loop until 0 
    ++p; // Move to the next character in the source code
    if (tk == '\n') {     // Check if the current character is a newline
     
      if (src) {  // If the source output flag is enabled
        printf("%d: %.*s", line, p - lp, lp); // Print the current line number and the entire line (from 'lp' to current position 'p')
        lp = p; // update the line pointer to the start of the next line 
        while (le < e) { // If code has been generated (from 'le' to 'e'), print each opcode and its operand
          printf("%8.4s", &"LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,"
                           "OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,"
                           "OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,"[*++le * 5]);
        // If the opcode takes an operand, print it
          if (*le <= ADJ) printf(" %d\n", *++le); else printf("\n"); 
        }
      }
      ++line; //increment line number 
    }
    
    // Else If the character is '#' (preprocessor directive), skip to the end of the line
    else if (tk == '#') { // If the character is '#' (preprocessor directive), skip to the end of the line
      while (*p != 0 && *p != '\n') ++p;
    }

    // If the character is a letter or underscore, it starts an identifier or keyword
    else if ((tk >= 'a' && tk <= 'z') || (tk >= 'A' && tk <= 'Z') || tk == '_') 
    { 
      pp = p - 1; // Set 'pp' to point to the beginning of the identifier
      // Continue reading letters, digits, or underscores to complete the identifier
      while ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9') || *p == '_')
        tk = tk * 147 + *p++; // Compute a simple hash value for the identifier
      tk = (tk << 6) + (p - pp); // Combine the hash with the identifier length for better distribution
      id = sym; // look up the identifer in the symbol table  
      while (id[Tk]) {  // While there are entries in the symbol table
        
        //If hash matches and the identifier strings match, set 'tk' to the token type stored in the symbol table, return if token successfully recognized
        if (tk == id[Hash] && !memcmp((char *)id[Name], pp, p - pp)) { tk = id[Tk]; return; } 
        
        id = id + Idsz;
      }

      id[Name] = (int)pp; // Store the pointer to the identifier's string
      id[Hash] = tk; // Store the computed hash value
      tk = id[Tk] = Id; // Mark token as identifier (Id) and update the table entry
      return;
    }
      
    // If the character is a digit, it starts a numeric literal (decimal, hexadecimal, or octal)
    else if (tk >= '0' && tk <= '9') {
      if (ival = tk - '0') { while (*p >= '0' && *p <= '9') ival = ival * 10 + *p++ - '0'; } // If the digit is non-zero, start accumulating a decimal number
      else if (*p == 'x' || *p == 'X') { // Check for hexadecimal literal (prefix "0x" or "0X")
        while ((tk = *++p) && ((tk >= '0' && tk <= '9') || (tk >= 'a' && tk <= 'f') || (tk >= 'A' && tk <= 'F')))
          ival = ival * 16 + (tk & 15) + (tk >= 'A' ? 9 : 0);
      }
      else { while (*p >= '0' && *p <= '7') ival = ival * 8 + *p++ - '0'; }  // Otherwise, treat it as an octal number
      tk = Num; // Set the token type to 'Num' (numeric literal)
      return;
    }

    // If the character is '/', it could be the start of a comment or a division operator
    else if (tk == '/') {
      if (*p == '/') { // If next character is '/', it's a comment 
        ++p; // Skip the second '/'
        while (*p != 0 && *p != '\n') ++p; // Skip all characters until end-of-line
      }
      else {  // Otherwise, treat '/' as the division operator
        tk = Div; // Set token type to 'Div'
        return;
      }
    }

    // If the token is a single quote or double quote, it starts a string or character literal
    else if (tk == '\'' || tk == '"') { 
      pp = data; // Save the current data pointer 
      while (*p != 0 && *p != tk) { // Read characters until the closing quote is found
        if ((ival = *p++) == '\\') { // If an escape character is found
          if ((ival = *p++) == 'n') ival = '\n'; // Handle '\n' escape sequence
        }
        // For string literals (double quotes), store the character in the data area
        if (tk == '"') *data++ = ival;
      }
      ++p; // Skip the closing quote
      if (tk == '"') ival = (int)pp; else tk = Num; // For strings, the literal's value is its address in the data area. For character constants, treat it as a numeric literal
      return;
    }


    else if (tk == '=') { if (*p == '=') { ++p; tk = Eq; } else tk = Assign; return; } // '=' can be assignment or equality check. If "==" then it's equality operator; else "=", then its assignment operator  
    else if (tk == '+') { if (*p == '+') { ++p; tk = Inc; } else tk = Add; return; } // '+' can be addition or increment operator
    else if (tk == '-') { if (*p == '-') { ++p; tk = Dec; } else tk = Sub; return; }    // '-' can be subtraction or decrement operator
    else if (tk == '!') { if (*p == '=') { ++p; tk = Ne; } return; } // '!' can be logical NOT or not-equal operator
    else if (tk == '<') { if (*p == '=') { ++p; tk = Le; } else if (*p == '<') { ++p; tk = Shl; } else tk = Lt; return; } // '<' can be less-than, less-than-or-equal, or left shift operator
    else if (tk == '>') { if (*p == '=') { ++p; tk = Ge; } else if (*p == '>') { ++p; tk = Shr; } else tk = Gt; return; }     // '>' can be greater-than, greater-than-or-equal, or right shift operator
    else if (tk == '|') { if (*p == '|') { ++p; tk = Lor; } else tk = Or; return; } // '|' can be bitwise OR or logical OR
    else if (tk == '&') { if (*p == '&') { ++p; tk = Lan; } else tk = And; return; } // '&' can be bitwise AND or logical AND
    else if (tk == '^') { tk = Xor; return; } // '^' is bitwise XOR
    else if (tk == '%') { tk = Mod; return; } // '%' is the modulus operator
    else if (tk == '*') { tk = Mul; return; } // '*' is the multiplication operator
    else if (tk == '[') { tk = Brak; return; }    // '[' is treated as an array subscript operator
    else if (tk == '?') { tk = Cond; return; } // '?' is the conditional operator (ternary)
    else if (tk == '~' || tk == ';' || tk == '{' || tk == '}' || tk == '(' || tk == ')' || tk == ']' || tk == ',' || tk == ':') return; // For other punctuation tokens (~, ;, {, }, (, ), ], , , :), simply return them as tokens.
  }
}


// The 'expr()' function parses an expression using a recursive descent parser with precedence climbing.
// The parameter 'lev' indicates the minimum precedence level that this call should handle.
void expr(int lev)
{
  int t, *d; // 't' temporarily holds a type or operator value; 'd' is used for jump address patching.

  // If no token is available, we've hit end-of-file unexpectedly in an expression.
  if (!tk) { printf("%d: unexpected eof in expression\n", line); exit(-1); }
  
  // If the current token is a numeric literal
  else if (tk == Num) { *++e = IMM; *++e = ival; next(); ty = INT; } //Emit an "immediate" opcode, Emit the literal value, Advance to the next token, the type of a number is INT

  // If the current token is a string literal (indicated by a double quote).
  else if (tk == '"') {
    *++e = IMM; *++e = ival; next(); //Emit immediate opcode, Emit the address (or value) of the string stored in the data area. "next()" Consume the string literal token.
    while (tk == '"') next(); //Skip any consecutive string tokens. Align 'data' pointer to a word boundary.
    data = (char *)((int)data + sizeof(int) & -sizeof(int)); ty = PTR; // A string literal's type is a pointer.
  }

  // If the token is the 'sizeof' keyword.
  else if (tk == Sizeof) {
    next(); if (tk == '(') next(); else { printf("%d: open paren expected in sizeof\n", line); exit(-1); } // Consume "sizeOf"; Expect and consume an open parenthesis.
    ty = INT; if (tk == Int) next(); else if (tk == Char) { next(); ty = CHAR; } // Default type for sizeof result is INT. Parse the type inside sizeof: either 'int' or 'char'.
    while (tk == Mul) { next(); ty = ty + PTR; } // Handle pointer types (e.g., int*, char*).
    // Expect and consume the closing parenthesis.
    if (tk == ')') next(); else { printf("%d: close paren expected in sizeof\n", line); exit(-1); } 
    *++e = IMM; *++e = (ty == CHAR) ? sizeof(char) : sizeof(int);     // Emit an immediate value representing the size of the type.
    ty = INT;
  }
  // If the token is an identifier (which may be a variable or function).
  else if (tk == Id) { 
    d = id; next(); // Save the symbol table entry for this identifier. consume the identifier token
    if (tk == '(') { // If the identifier is followed by '(', it is a function call.
      next(); // Consume the '('.
      t = 0; // Counter for number of arguments.
      while (tk != ')') {// Parse arguments until the closing parenthesis.
        expr(Assign); *++e = PSH; ++t; if (tk == ',') next(); } // Parse each argument (using assignment precedence). Push the argument value onto the stack.  Increment argument count. Consume comma between arguments. 
      next(); // Consume the closing ')'.
      // Determine whether it's a system (built-in) or user-defined function.
      if (d[Class] == Sys) *++e = d[Val];  // Emit a system call opcode.
      else if (d[Class] == Fun) { *++e = JSR; *++e = d[Val]; } // Emit a jump-to-subroutine opcode with function address.
      else { printf("%d: bad function call\n", line); exit(-1); }

      if (t) { *++e = ADJ; *++e = t; } // If there were any arguments, adjust the stack to remove them.
      ty = d[Type]; // Set the type to the function's return type.
    }
    // If the identifier represents a numeric constant (e.g. from an enum)
    else if (d[Class] == Num) { *++e = IMM; *++e = d[Val]; ty = INT; }
    else { // Otherwise, treat the identifier as a variable.
      if (d[Class] == Loc) { *++e = LEA; *++e = loc - d[Val]; } // Load effective address for a local variable.
      else if (d[Class] == Glo) { *++e = IMM; *++e = d[Val]; } // Load immediate value for a global variable.
      else { printf("%d: undefined variable\n", line); exit(-1); }
      *++e = ((ty = d[Type]) == CHAR) ? LC : LI; // Emit code to load a character (LC) or integer (LI) from the computed address.
    }
  }

  // Handle expressions inside parentheses.
  else if (tk == '(') {
    next(); // Consume '('.
    // If a type keyword is detected, this is a cast.
    if (tk == Int || tk == Char) {
      t = (tk == Int) ? INT : CHAR; next();// Determine the type.
      while (tk == Mul) { next(); t = t + PTR; } // Handle pointer casting (e.g., int**).
      if (tk == ')') next(); else { printf("%d: bad cast\n", line); exit(-1); }
      expr(Inc); // Parse the expression being cast.
      ty = t; // Set the result type to the cast type.
    }
    else { // Otherwise, simply evaluate the parenthesized expression.
      expr(Assign);
      if (tk == ')') next(); else { printf("%d: close paren expected\n", line); exit(-1); }
    }
  }
  // Handle pointer dereference operator '*'.
  else if (tk == Mul) {
    next(); expr(Inc);// Consume the '*' operator. Parse the operand at the next level of precedence.
    // Ensure the type is a pointer (ty > INT) before dereferencing.
    if (ty > INT) ty = ty - PTR; else { printf("%d: bad dereference\n", line); exit(-1); } // Emit the load operation: LC for char pointers, LI for integer pointers.
    *++e = (ty == CHAR) ? LC : LI;
  }
  // Handle the address-of operator '&'.
  else if (tk == And) {
    next(); expr(Inc);// Consume the '&' operator; parse the operand 
    // The result of address-of must be an lvalue; check if the last opcode is LC or LI.
    if (*e == LC || *e == LI) --e; else { printf("%d: bad address-of\n", line); exit(-1); }// Remove the load instruction, leaving the address.
    ty = ty + PTR;  // The result is a pointer to the original type.
  }
    // Handle the logical NOT operator '!'
  else if (tk == '!') { next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = 0; *++e = EQ; ty = INT; }// Push 0 onto the stack and compare: result is 1 if operand was 0, 0 otherwise. Logical result is an integer.
  else if (tk == '~') { next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = -1; *++e = XOR; ty = INT; }// Handle the bitwise NOT operator '~'. Push -1 and perform XOR: effectively inverts the bits.
  else if (tk == Add) { next(); expr(Inc); ty = INT; }// Handle unary plus '+' (does nothing but advances the token)
  else if (tk == Sub) {// Handle unary minus '-' (negation)
    next(); *++e = IMM; //Consume '-'. Emit an immediate opcode for negation.
    if (tk == Num) { *++e = -ival; next(); } // If the next token is a number, simply negate it.
    else { *++e = -1; *++e = PSH; expr(Inc); *++e = MUL; }// Otherwise, push -1 and multiply by the operand to perform negation.
    ty = INT;
  }
  // Handle pre-increment '++' or pre-decrement '--'
  else if (tk == Inc || tk == Dec) {
    t = tk; next(); expr(Inc); // Save whether it's an increment or decrement.
    if (*e == LC) { *e = PSH; *++e = LC; }// Ensure the operand is a valid lvalue (memory load operation).
    else if (*e == LI) { *e = PSH; *++e = LI; } 
    else { printf("%d: bad lvalue in pre-increment\n", line); exit(-1); }
    // Perform the increment or decrement:
    *++e = PSH;
    *++e = IMM; *++e = (ty > PTR) ? sizeof(int) : sizeof(char);
    *++e = (t == Inc) ? ADD : SUB;
    *++e = (ty == CHAR) ? SC : SI;// Store the result back.
  }
  else { printf("%d: bad expression\n", line); exit(-1); }  // If none of the above patterns match, it's an error in the expression.

  while (tk >= lev) { // "precedence climbing" or "Top Down Operator Precedence" method
    t = ty;// Save the current expression type.
    if (tk == Assign) {
      next();// Consume assignment operator.
       // Check that the left-hand side is a valid lvalue.
      if (*e == LC || *e == LI) *e = PSH; // Replace the load with a push if it's a valid lvalue.
      else { printf("%d: bad lvalue in assignment\n", line); exit(-1); }
      expr(Assign);// Parse the right-hand side with assignment precedence.
      *++e = ((ty = t) == CHAR) ? SC : SI;// Emit the store instruction: SC for char or SI for integer.
    }
    else if (tk == Cond) { // Ternary conditional operator ( ? : )
      next(); //consume'?'
      *++e = BZ; d = ++e;// Emit branch if zero. Reserve space for jump address.
      expr(Assign); // Parse the 'true' expression.
      if (tk == ':') next(); else { printf("%d: conditional missing colon\n", line); exit(-1); }
      *d = (int)(e + 3); *++e = JMP; d = ++e; // Patch the jump to skip the false part. Emit unconditional jump. Reserve space for jump address.
      expr(Cond); // Parse the 'false' expression.
      *d = (int)(e + 1); //Patch the jump address.
    }
    // The following else-if statements handle binary operators with various precedence levels.
    else if (tk == Lor) { next(); *++e = BNZ; d = ++e; expr(Lan); *d = (int)(e + 1); ty = INT; } //Logical OR '||'. Branch if not zero. 'expr(Lan)': Parse the right-hand operand with lower precedence. Patch jump address.
    else if (tk == Lan) { next(); *++e = BZ;  d = ++e; expr(Or);  *d = (int)(e + 1); ty = INT; } //Logical AND '&&'.Branch if zero. Parse right-hand operand.
    else if (tk == Or)  { next(); *++e = PSH; expr(Xor); *++e = OR;  ty = INT; } // Bitwise OR '|'
    else if (tk == Xor) { next(); *++e = PSH; expr(And); *++e = XOR; ty = INT; } // Bitwise XOR '^'
    else if (tk == And) { next(); *++e = PSH; expr(Eq);  *++e = AND; ty = INT; } // Bitwise AND '&'
    else if (tk == Eq)  { next(); *++e = PSH; expr(Lt);  *++e = EQ;  ty = INT; } // Equality '=='
    else if (tk == Ne)  { next(); *++e = PSH; expr(Lt);  *++e = NE;  ty = INT; } // Not equal '!='
    else if (tk == Lt)  { next(); *++e = PSH; expr(Shl); *++e = LT;  ty = INT; } // Less-than '<'
    else if (tk == Gt)  { next(); *++e = PSH; expr(Shl); *++e = GT;  ty = INT; } // Greater-than '>'
    else if (tk == Le)  { next(); *++e = PSH; expr(Shl); *++e = LE;  ty = INT; } // Less-than-or-equal '<='
    else if (tk == Ge)  { next(); *++e = PSH; expr(Shl); *++e = GE;  ty = INT; } // Greater-than-or-equal '>='
    else if (tk == Shl) { next(); *++e = PSH; expr(Add); *++e = SHL; ty = INT; } // Bitwise shift left '<<'
    else if (tk == Shr) { next(); *++e = PSH; expr(Add); *++e = SHR; ty = INT; } // Bitwise shift right '>>'
    else if (tk == Add) {// Addition '+'
      next(); *++e = PSH; expr(Mul);
      // If the left operand is a pointer, scale the addition by the size of the pointed type.
      if ((ty = t) > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL;  }
      *++e = ADD; //emit ADD opcode
    }
   
    else if (tk == Sub) {//if '-' operator. 
      next(); *++e = PSH; expr(Mul); //consume '-'. push current value. parse RH side expression    
      // Handle pointer subtraction differently:
      if (t > PTR && t == ty) { *++e = SUB; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = DIV; ty = INT; }
      else if ((ty = t) > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL; *++e = SUB; }
      else *++e = SUB; //emit SUB opcode 
    }
    else if (tk == Mul) { next(); *++e = PSH; expr(Inc); *++e = MUL; ty = INT; } // Consume '*'. Push current value.Parse right-hand side expression. Emit MUL opcode. Result is an integer.
    else if (tk == Div) { next(); *++e = PSH; expr(Inc); *++e = DIV; ty = INT; }// Consume '/'. Push current value.Parse right-hand side expression. Emit DIV opcode. Result is an integer.
    else if (tk == Mod) { next(); *++e = PSH; expr(Inc); *++e = MOD; ty = INT; } // Consume '%'. Push current value.Parse right-hand side expression. Emit MOD opcode. Result is an integer.
    else if (tk == Inc || tk == Dec) { //post-increment(++) or post-decrement (--) operators.
      // Check that the left-hand side is a valid lvalue.
      if (*e == LC) { *e = PSH; *++e = LC; } 
      else if (*e == LI) { *e = PSH; *++e = LI; }
      else { printf("%d: bad lvalue in post-increment\n", line); exit(-1); }
      
      // Adjust the value by the size of the type and then restore the original value.
      *++e = PSH; *++e = IMM; *++e = (ty > PTR) ? sizeof(int) : sizeof(char);
      *++e = (tk == Inc) ? ADD : SUB;
      *++e = (ty == CHAR) ? SC : SI;
      *++e = PSH; *++e = IMM; *++e = (ty > PTR) ? sizeof(int) : sizeof(char);
      *++e = (tk == Inc) ? SUB : ADD;
      next();
    }
    else if (tk == Brak) {// Handle array subscript operator [].
      next(); *++e = PSH; expr(Assign); //consume '['. Push the base pointer (address of the array). Parse the index expression
      if (tk == ']') next(); else { printf("%d: close bracket expected\n", line); exit(-1); } //consume ']'.
      // For pointer arithmetic: if the element type is not char, multiply index by sizeof(int).
      if (t > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL;  }
      else if (t < PTR) { printf("%d: pointer type expected\n", line); exit(-1); }
      *++e = ADD; // Add the index offset to the base address.
      *++e = ((ty = t - PTR) == CHAR) ? LC : LI; // Load the value from the computed address: LC if char, LI if int.

    }
    else { printf("%d: compiler error tk=%d\n", line, tk); exit(-1); }
  } // End of binary operator processing loop.
}


// The 'stmt()' function parses a single statement.
// It handles control flow constructs (if, while), blocks, return statements, and expression statements. It emits appropriate opcodes for each statement.
void stmt()
{
  int *a, *b; // Pointers used to store jump addresses for conditional and loop control flow.

  // If statement: if (condition) statement [else statement]
  if (tk == If) {
    next(); // Consume 'if' token.
    if (tk == '(') next(); // Ensure the condition is enclosed in parentheses.
    else { printf("%d: open paren expected\n", line); exit(-1); }
    expr(Assign); // Parse the condition expression.
    if (tk == ')') next(); else { printf("%d: close paren expected\n", line); exit(-1); }
    *++e = BZ; b = ++e; // Emit "branch if zero" (BZ) opcode for the false condition; Store address for later backpatching (jump to else or end).
    stmt(); // Parse the "then" statement.
    if (tk == Else) { // If there's an "else" part, process it.
      *b = (int)(e + 3); // Fix 'if' false branch to jump past the 'else' statement.
      *++e = JMP; // Emit "unconditional jump" (JMP) to skip over the 'else' body.
      b = ++e; // Store this jump address for backpatching.
      next(); // Consume 'else' token.
      stmt(); //parse "else" statement
    }
    *b = (int)(e + 1); // Fix jump address to ensure proper control flow.
  }
  // While loop: while (condition) statement
  else if (tk == While) {
    next(); // Consume 'while' token.
    a = e + 1;  // Store the address of the beginning of the loop condition.
    if (tk == '(') next(); else { printf("%d: open paren expected\n", line); exit(-1); }   // Ensure the loop condition is enclosed in parentheses.
    expr(Assign); // Parse the loop condition.
    if (tk == ')') next(); else { printf("%d: close paren expected\n", line); exit(-1); }
    *++e = BZ; b = ++e;// Emit "branch if zero" (BZ) opcode to exit the loop if the condition is false;Store the exit jump address for later backpatching.
    stmt(); // Parse the loop body.
    *++e = JMP; *++e = (int)a; // Emit "unconditional jump" (JMP) to go back to loop condition; Jump back to the condition check.
    *b = (int)(e + 1); // Fix jump address to exit the loop when condition is false.
  }
  else if (tk == Return) {// Return statement: return [expression];
    next(); // Consume 'return' token.
    if (tk != ';') expr(Assign); // If there is an expression, evaluate and return it.
    *++e = LEV;// Emit "leave function" (LEV) opcode to return from function.
    if (tk == ';') next(); else { printf("%d: semicolon expected\n", line); exit(-1); }
  }
  else if (tk == '{') { // Block statement: { statement; statement; ... }
    next(); // Consume '{'.
    while (tk != '}') stmt(); // Recursively parse statements inside the block.
    next(); // Consume '}'.
  }
  else if (tk == ';') { // Empty statement: just a semicolon.
    next(); // Consume ';'.
  }
  else { // Expression statement: expr;
    expr(Assign); // Parse an expression.
    if (tk == ';') next(); else { printf("%d: semicolon expected\n", line); exit(-1); }
  }
}

// The 'main()' function sets up the compiler, parses the source file, and either outputs the generated code (if in source/assembly output mode) or executes it using the built-in virtual machine.
// Entry point of the compiler and virtual machine. It initializes memory, parses the source code, and executes the compiled program.
int main(int argc, char **argv)
{
  int fd, bt, ty, poolsz, *idmain; // File descriptor, base type, type, memory pool size, and main function ID.
  int *pc, *sp, *bp, a, cycle; // vm registers: : program counter, stack pointer, base pointer, accumulator, and cycle counter.
  int i, *t; // temporary variables 

  // Process command-line arguments
  --argc; ++argv;
  if (argc > 0 && **argv == '-' && (*argv)[1] == 's') { src = 1; --argc; ++argv; } // Enable source code printing
  if (argc > 0 && **argv == '-' && (*argv)[1] == 'd') { debug = 1; --argc; ++argv; } // Enable debug mode
  if (argc < 1) { printf("usage: c4 [-s] [-d] file ...\n"); return -1; } // Check if a source file is provided

  // Open the source file.
  if ((fd = open(*argv, 0)) < 0) { printf("could not open(%s)\n", *argv); return -1; }

  // Allocate memory for different components of the compiler
  poolsz = 256*1024; // arbitrary size
  if (!(sym = malloc(poolsz))) { printf("could not malloc(%d) symbol area\n", poolsz); return -1; }
  if (!(le = e = malloc(poolsz))) { printf("could not malloc(%d) text area\n", poolsz); return -1; }
  if (!(data = malloc(poolsz))) { printf("could not malloc(%d) data area\n", poolsz); return -1; }
  if (!(sp = malloc(poolsz))) { printf("could not malloc(%d) stack area\n", poolsz); return -1; }

  // Initialize memory
  memset(sym,  0, poolsz);
  memset(e,    0, poolsz);
  memset(data, 0, poolsz);

  // Define keywords and system functions
  p = "char else enum if int return sizeof while "
      "open read close printf malloc free memset memcmp exit void main";
  i = Char; while (i <= While) { next(); id[Tk] = i++; } // add keywords to symbol table
  // Initialize system (library) functions in the symbol table.
  i = OPEN; while (i <= EXIT) { next(); id[Class] = Sys; id[Type] = INT; id[Val] = i++; } // add library to symbol table
  next(); id[Tk] = Char; // handle void type
  next(); idmain = id; // keep track of main

  // Load source code into memory
  if (!(lp = p = malloc(poolsz))) { printf("could not malloc(%d) source area\n", poolsz); return -1; }
  if ((i = read(fd, p, poolsz-1)) <= 0) { printf("read() returned %d\n", i); return -1; }
  p[i] = 0; // Null-terminate the source code
  close(fd);

  // Start parsing global declarations.
  line = 1;
  next();
  while (tk) {
    bt = INT; // Default base type is int
    if (tk == Int) next();
    else if (tk == Char) { next(); bt = CHAR; }
    else if (tk == Enum) { // Handle enums
      next();
      if (tk != '{') next();
      if (tk == '{') {
        next();
        i = 0;
        while (tk != '}') {
          if (tk != Id) { printf("%d: bad enum identifier %d\n", line, tk); return -1; }
          next();
          if (tk == Assign) {
            next();
            if (tk != Num) { printf("%d: bad enum initializer\n", line); return -1; }
            i = ival;
            next();
          }
          // Store the enumerator value in the symbol table.
          id[Class] = Num; id[Type] = INT; id[Val] = i++;
          if (tk == ',') next();
        }
        next();
      }
    }
    while (tk != ';' && tk != '}') { // Handle global variables and functions
      ty = bt;
      while (tk == Mul) { next(); ty = ty + PTR; } // Handle pointer types
      if (tk != Id) { printf("%d: bad global declaration\n", line); return -1; }
      if (id[Class]) { printf("%d: duplicate global definition\n", line); return -1; }
      next();
      id[Type] = ty;
      if (tk == '(') { // function definition 
        id[Class] = Fun;
        id[Val] = (int)(e + 1);
        next(); i = 0;
        while (tk != ')') { // Parse function parameters
          ty = INT;
          if (tk == Int) next();
          else if (tk == Char) { next(); ty = CHAR; }
          while (tk == Mul) { next(); ty = ty + PTR; }
          if (tk != Id) { printf("%d: bad parameter declaration\n", line); return -1; }
          if (id[Class] == Loc) { printf("%d: duplicate parameter definition\n", line); return -1; }
          // Save old values for parameters and mark as local.
          id[HClass] = id[Class]; id[Class] = Loc;
          id[HType]  = id[Type];  id[Type] = ty;
          id[HVal]   = id[Val];   id[Val] = i++;
          next();
          if (tk == ',') next();
        }
        next();
        if (tk != '{') { printf("%d: bad function definition\n", line); return -1; }
        loc = ++i; // Set local variable offset.
        next();
        while (tk == Int || tk == Char) { // Parse local variable declarations
          bt = (tk == Int) ? INT : CHAR;
          next();
          while (tk != ';') {
            ty = bt;
            while (tk == Mul) { next(); ty = ty + PTR; }
            if (tk != Id) { printf("%d: bad local declaration\n", line); return -1; }
            if (id[Class] == Loc) { printf("%d: duplicate local definition\n", line); return -1; }
            id[HClass] = id[Class]; id[Class] = Loc;
            id[HType]  = id[Type];  id[Type] = ty;
            id[HVal]   = id[Val];   id[Val] = ++i;
            next();
            if (tk == ',') next();
          }
          next();
        }
        // Emit function entry code: reserve space for local variables.
        *++e = ENT; *++e = i - loc;
        while (tk != '}') stmt(); // Parse function body statements.
        *++e = LEV; // Emit function exit code.
        id = sym; // Unwind the symbol table: restore previous values for local variables.
        while (id[Tk]) {
          if (id[Class] == Loc) {
            id[Class] = id[HClass];
            id[Type] = id[HType];
            id[Val] = id[HVal];
          }
          id = id + Idsz;
        }
      }
      else { // Global variable declaration.
        id[Class] = Glo;
        id[Val] = (int)data;  // Allocate space from the data area.
        data = data + sizeof(int);
      }
      if (tk == ',') next();
    }
    next();
  }

  // Ensure main() function exists
  if (!(pc = (int *)idmain[Val])) { printf("main() not defined\n"); return -1; }
  if (src) return 0; // If printing source/assembly, exit now.

  // setup stack
  bp = sp = (int *)((int)sp + poolsz);
  *--sp = EXIT; // call exit if main returns
  *--sp = PSH; t = sp;
  *--sp = argc;
  *--sp = (int)argv;
  *--sp = (int)t;

   // Virtual Machine Execution Loop:
  // 'cycle' counts the number of executed instructions.
  // run...
  cycle = 0;
  while (1) {
    i = *pc++; // Fetch the next instruction.
    ++cycle;
    // If debug mode is enabled, print the current instruction and its operand.
    if (debug) {
      printf("%d> %.4s", cycle,
        &"LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,"
         "OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,"
         "OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,"[i * 5]);
      if (i <= ADJ) printf(" %d\n", *pc); else printf("\n");
      // Execute VM instructions (loads, jumps, function calls, arithmetic, etc.)
    }
    if      (i == LEA) a = (int)(bp + *pc++);                             // load local address
    else if (i == IMM) a = *pc++;                                         // load global address or immediate
    else if (i == JMP) pc = (int *)*pc;                                   // jump
    else if (i == JSR) { *--sp = (int)(pc + 1); pc = (int *)*pc; }        // jump to subroutine
    else if (i == BZ)  pc = a ? pc + 1 : (int *)*pc;                      // branch if zero
    else if (i == BNZ) pc = a ? (int *)*pc : pc + 1;                      // branch if not zero
    else if (i == ENT) { *--sp = (int)bp; bp = sp; sp = sp - *pc++; }     // enter subroutine
    else if (i == ADJ) sp = sp + *pc++;                                   // stack adjust
    else if (i == LEV) { sp = bp; bp = (int *)*sp++; pc = (int *)*sp++; } // leave subroutine
    else if (i == LI)  a = *(int *)a;                                     // load int
    else if (i == LC)  a = *(char *)a;                                    // load char
    else if (i == SI)  *(int *)*sp++ = a;                                 // store int
    else if (i == SC)  a = *(char *)*sp++ = a;                            // store char
    else if (i == PSH) *--sp = a;                                         // push

    // Arithmetic and bitwise operations:
    else if (i == OR)  a = *sp++ |  a;
    else if (i == XOR) a = *sp++ ^  a;
    else if (i == AND) a = *sp++ &  a;
    else if (i == EQ)  a = *sp++ == a;
    else if (i == NE)  a = *sp++ != a;
    else if (i == LT)  a = *sp++ <  a;
    else if (i == GT)  a = *sp++ >  a;
    else if (i == LE)  a = *sp++ <= a;
    else if (i == GE)  a = *sp++ >= a;
    else if (i == SHL) a = *sp++ << a;
    else if (i == SHR) a = *sp++ >> a;
    else if (i == ADD) a = *sp++ +  a;
    else if (i == SUB) a = *sp++ -  a;
    else if (i == MUL) a = *sp++ *  a;
    else if (i == DIV) a = *sp++ /  a;
    else if (i == MOD) a = *sp++ %  a;

    // System calls and library function emulation:
    else if (i == OPEN) a = open((char *)sp[1], *sp);
    else if (i == READ) a = read(sp[2], (char *)sp[1], *sp);
    else if (i == CLOS) a = close(*sp);
    else if (i == PRTF) { t = sp + pc[1]; a = printf((char *)t[-1], t[-2], t[-3], t[-4], t[-5], t[-6]); }
    else if (i == MALC) a = (int)malloc(*sp);
    else if (i == FREE) free((void *)*sp);
    else if (i == MSET) a = (int)memset((char *)sp[2], sp[1], *sp);
    else if (i == MCMP) a = memcmp((char *)sp[2], (char *)sp[1], *sp);
    // Exit the program.
    else if (i == EXIT) { printf("exit(%d) cycle = %d\n", *sp, cycle); return *sp; }
    else { printf("unknown instruction = %d! cycle = %d\n", i, cycle); return -1; }
  }
}
